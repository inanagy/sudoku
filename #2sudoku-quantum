#空白セル40%(空白セル6)
from hobotan import *
import numpy as np
import sys
from itertools import combinations


input = np.array([
        [0, 0, 1, 0],
        [3, 1, 4, 2],
        [1, 2, 3, 4],
        [0, 3, 0, 0]
    ])
jump = 2
    size = 4

for seed_value in [0, 1, 2, 3, 4]:
    print(f"\n=== SEED = {seed_value} ===")
    q = symbols_list([size, size, 2], 'q{}_{}_{}')

    #Cell constraint
    for i in range(size):
        for j in range(size):
            if input[i][j] != 0:
                bit = format(input[i, j] - 1, '02b')
                q[i][j][0] = int(bit[0])
                q[i][j][1] = int(bit[1])

    Hconst = 0


    #Row constraint
    for i in range(size):
        for a, b in combinations(range(size), 2):
            Hconst += (1 - (q[i][a][1] - q[i][b][1])**2) * (1 - (q[i][a][0] - q[i][b][0])**2)

    #Column constraint
    for i in range(size):
        for a, b in combinations(range(size), 2):
            Hconst +=  (1 - (q[a][i][1] - q[b][i][1])**2) * (1 - (q[a][i][0] - q[b][i][0])**2)



    #Block constraint
    for i in range(0, size, jump):
        for j in range(0, size, jump):
            array = []
            for x in range(jump):
                for y in range(jump):
                    array.extend([q[i+x, j+y, 1], q[i+x, j+y, 0] ])

            # Convert numpy array
            a = np.array(array)

            # Reshape to 2x2x2
            b = a.reshape(jump, jump, 2)

            # Reshape to 4x2
            c = b.reshape(size, 2)

            #Constraints for each block
            for a, b in combinations(range(size), 2):
                 Hconst += (1 - (c[a][1] - c[b][1])**2) * (1 - (c[a][0] - c[b][0])**2)



    # Complie the HOBO tensor
    hobo, offset = Compile(Hconst).get_hobo()

    # Select the sampler with specified seed
    solver = sampler.MIKASAmpler(seed=seed_value)

    # Sampling
    result = solver.run(hobo, shots=10000, T_num = 100000)

    # Display top 3 results
    for idx, r in enumerate(result[:3]):
        print(f"Result {idx+1}: Energy {r[1]}, Occurrence {r[2]}")

        # arr を -1 で初期化
        arr = np.ones([size, size, 2], int) * -1

        for i in range(size):
            for j in range(size):
                # 固定セルなら input をそのままビットへ
                if input[i][j] != 0:
                    bit = format(input[i][j] - 1, '02b')
                    arr[i, j, 0] = int(bit[0])
                    arr[i, j, 1] = int(bit[1])
                else:
                    for k in range(2):
                        key = f'q{i}_{j}_{k}'
                        if key in r[0]:
                            arr[i, j, k] = r[0][key]

        # 2ビットを数値に変換して +1
        ans = (
            arr[:, :, 0] * 2**1
          + arr[:, :, 1] * 2**0
        ) + 1
        print(ans)

        #正しいか判定
        correct = np.array([
        [2, 4, 1, 3],
        [3, 1, 4, 2],
        [1, 2, 3, 4],
        [4, 3, 2, 1]
    ])
        print(np.sum(np.abs(ans - correct)) == 0)
